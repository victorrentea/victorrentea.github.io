# Avoiding NullPointerException
From all the standard Java exceptions, let's talk about the terrible `NullPointerException`, NPE in short. [A 2016 study](https://www.overops.com/blog/the-top-10-exceptions-types-in-production-java-applications-based-on-1b-events/) awarded NPE the 1st place in the topmost frequent Java exceptions occurring in production. We’ll explore two techniques to fight it: the self-validating model and the `Optional`.

## Self-Validating Model    

Imagine a business rule: every Customer has to have a birth date set. There are a number of ways to implement this constraint: validating the data on the create and update use-cases, enforcing it via `NOT NULL` database constraint and/or implementing the null-check right in the constructor of the Customer entity. In this article we'll explore the last one.

Here are the 3 most used forms to null-check in constructor today:

    public Customer(@NonNull Date birthDate) { // 3
      if (birthDate == null) { // 1
         throw new IllegalArgumentException();
      }
      this.birthDate = Objects.requireNonNull(birthDate); // 2
    }

The code above contains 3 _alternative_ ways to do the same thing, any single one is of course enough:
1. Classic `if` check
2. One-liner check using Java 8 `java.util.Objects` - most widely used in projects under development today
3. Lombok `@NonNull` causing an `if` check to be added to the generated bytecode.

If there is a setter for birth date, the check will move there, leaving the constructor to call that setter. 

Enforcing the null-check in the constructor of your data objects has obvious advantages: no one could ever forget to do it. However, frameworks writing directly to the fields of the instance via reflection may bypass this check. Hibernate does this by default, so my advice is to also mark the corresponding required columns as `NOT NULL` in the database. Unfortunately, the problem can get more complicated in legacy systems by having to tolerate 'incorrect historical data’.

> **Trick**: Hibernate requires a no-arg constructor on every persistent entity, but that constructor can be marked as `protected` to hide it from normal use. 

The moment all your data objects enforce the validity of their state internally, you do get a better night sleep, but there's also a price to pay: creating dummy incomplete instances in tests becomes impossible. The typical tradeoff is relying more on [Object Mothers](https://martinfowler.com/bliki/ObjectMother.html) for building valid test objects.

But what if that `null` is really a valid value? For example, imagine our Customer might have a `null` Member Card, meaning that she didn’t yet create or maybe she didn’t want to sign up for a member card. 

## Getters returning `Optional<>`
> **Best-practice**: Since Java 8, whenever a function needs to return `null`, it should declare to return `Optional<>` instead

Developers rapidly adopted this practice for functions computing value or fetching remote data. Unfortunately, that left the main source of nulls untouched: our entity model:

> A getter for a field which may be `null` should return `Optional`.

Assuming we're talking about an Entity mapped to a relational database, then if you didn't enforce `NOT NULL` on the corresponding column, the getter for that field should return `Optional`. For non-persistent data objects or NoSQL datastores that don't offer `null` protection, the previous section might provide ideas on how enforce null-checks programmatically in the entity code. 

This change might seem frightening at first because we’re touching the 'sacred' getter we are all so familiar with. And yes, changing a getter in a large codebase may impact up to dozens of places. To ease the transition, you could use the following sequence of steps: 

1. Create a second getter returning `Optional`:
    ```
    public Optional<String> getMemberCardOpt() {
      return Optional.ofNullable(memberCard);
    }
    ```

2. Change the original getter to call the `Optional` one:
    ```
    public String getMemberCard() {
      return getMemberCardOpt().orElse(null);
    }
    ```

3. Make sure all the Java projects using the owner class are loaded in your workspace.
3. **Inline** the original getter everywhere. Everyone will end up calling `getMemberCardOpt()`.
4. **Rename** the getter to the default name (removing the `Opt` suffix)

You're done, with zero compilation failures. After you do this, everyone previously calling the getter will now do `getMemberCard().orElse(null);`. In some cases this might be the right thing to do, as in: `dto.phone=customer.getPhone().orElse(null);`

But let's suppose you wanted to use a property of the MemberCard, and you were careful to check for `null`:
```
if (customer.getMemeberCard() != null) { // Line X
    applyDiscount(order, customer.getMemeberCard().getFidelityPoints());
}
```
After applying the steps above, the code gets refactored to 
```
if (customer.getMemeberCard().orElse(null) != null) { // Line X
    applyDiscount(order, customer.getMemeberCard().orElse(null).getFidelityPoints());
}
```
The `if` condition can be simplified by using `.isPresent()` and the second line by using `.get()`. Then one could even shorten the code to a single line:
```
customer.getMemberCard().ifPresent(card -> applyDiscount(order, card.getFidelityPoints()));
```
This means that you still need to go through all the places the getter is called to *improve* the code as we saw above. Furthermore, I bet that in large codebases you'll also discover places where the null-check (// Line X) was forgotten because the developer was tired/careless/rushing back then. It happened on our project: we discovered dozens of `NullPointerExcepton`s just waiting to happen:
```
applyDiscount(order, customer.getMemeberCard().orElse(null).getFidelityPoints());
```
**Tip**: An IntelliJ inspection ('Constant conditions and exceptions') will hint you about the possible NPE in this case, so have it turned on. 


Our next concern is: would the frameworks be ok with getters returning `Optional`? 

First of all, to make it clear, we only changed the return type of the getter. The setter and the field type keep using the raw reference type (not `Optional`). 

Secondly, we should apply this technique only on data objects we write logic with. That is, Entities. As I explained in my [Clean Architecture talk](https://www.youtube.com/watch?v=tMHO7_RLxgQ&list=PLggcOULvfLL_MfFS_O0MKQ5W_6oWWbIw5&index=3), you should avoid writing heavy logic on API data objects (aka Data Transfer Objects). So `Optional<>` is for Entity model not DTO/API model.

Thirdly, all modern object-mapper frameworks (eg Hibernate, Mongo, Cassandra, Jackson, JAXB ...) can be instructed to read from the private fields via reflection (Hibernated does it by default), so they really don’t care about your getter. 

Signaling the caller at compile-time that there might be nothing returned to her is an extremely powerful technique. Most NPEs occur in large projects mainly because developers aren’t fully aware  some parts of the data might be missing, some fields might be `null`. I would strongly advise that you upgrade your entity model such that for every nullable field, the getter returns `Optional<>`. The effort of changing the getters of the core entities in your app is considerable, but along the way, you’ll may find many  dormant NPEs. And at the end, the rate of NPE bugs will be halved (at least), since the main source of nulls in your app, your entity model, will be null-safe.


In conclusion, there are two major best practices in dealing with null: throw as early as possible or wrap the possible null into an `Optional`.
